#!/usr/bin/env node

var fs = require('fs')
var dz = require('dezalgo')
var glob = require('glob')
var watch = require('chokidar').watch
var build = require('./build')
var buildcss = require('./build-css')
var watchify = require('watchify')
var browserify = require('browserify')
var serve = require('./serve')

build(function (err) {
  if (err) onerror(err)

  watchstyle()
  watchclient()
  startserver()
})

function watchstyle () {
  watch(glob.sync(__dirname + '/../src/**/*.css'), { ignoreInitial: true }).on('all', buildstyle)
}

function watchclient () {
  var w = watchify(browserify(__dirname + '/../index.js'), watchify.args)
  w.transform('txtify2', { extensions: [ 'html' ] })
  w.transform('envify')
  w.transform('browserify-versionify')
  w.on('update', buildclient.bind(null, w))

  // watchify apparently needs to be bundled manually 1x before update will fire
  w.bundle()
    .on('error', function () {
      // we can ignore errors here - the initial call to build will have logged these
    })
}

function buildstyle () {
  buildcss(function (err) {
    if (err) onerror(err)
    else onlog('style rebuilt')
  })
}

function buildclient (w) {
  var cb = dz(function (err) {
    if (err) {
      err.message = 'error building client: ' + err.message
      onerror(err)
    }
    else onlog('client rebuilt')
  })

  var file = fs.createWriteStream(__dirname + '/../share/build.js')
  file.on('finish', cb)
  file.on('error', cb)

  w.bundle()
    .on('error', cb)
    .pipe(file)
}

function startserver () {
  serve(function (err) {
    if (err) onerror(err)
    else onlog('server restarted on ' + process.env.PORT)
  })
}

function onlog (msg) {
  console.log(stamptime(), msg)
}

function onerror (err) {
  console.error(stamptime(), err.message)
}

function stamptime () {
  return '[ ' + (new Date()).getTime() + ' ]'
}
